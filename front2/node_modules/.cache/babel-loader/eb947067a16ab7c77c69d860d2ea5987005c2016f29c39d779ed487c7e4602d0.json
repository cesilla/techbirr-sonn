{"ast":null,"code":"import nacl from 'tweetnacl-util';\nimport nacl$1 from 'tweetnacl';\nvar CONNECT_EVENT_ERROR_CODES;\n(function (CONNECT_EVENT_ERROR_CODES) {\n  CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES[\"UNKNOWN_ERROR\"] = 0] = \"UNKNOWN_ERROR\";\n  CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES[\"BAD_REQUEST_ERROR\"] = 1] = \"BAD_REQUEST_ERROR\";\n  CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES[\"MANIFEST_NOT_FOUND_ERROR\"] = 2] = \"MANIFEST_NOT_FOUND_ERROR\";\n  CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES[\"MANIFEST_CONTENT_ERROR\"] = 3] = \"MANIFEST_CONTENT_ERROR\";\n  CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES[\"UNKNOWN_APP_ERROR\"] = 100] = \"UNKNOWN_APP_ERROR\";\n  CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES[\"USER_REJECTS_ERROR\"] = 300] = \"USER_REJECTS_ERROR\";\n  CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES[\"METHOD_NOT_SUPPORTED\"] = 400] = \"METHOD_NOT_SUPPORTED\";\n})(CONNECT_EVENT_ERROR_CODES || (CONNECT_EVENT_ERROR_CODES = {}));\nvar CONNECT_ITEM_ERROR_CODES;\n(function (CONNECT_ITEM_ERROR_CODES) {\n  CONNECT_ITEM_ERROR_CODES[CONNECT_ITEM_ERROR_CODES[\"UNKNOWN_ERROR\"] = 0] = \"UNKNOWN_ERROR\";\n  CONNECT_ITEM_ERROR_CODES[CONNECT_ITEM_ERROR_CODES[\"METHOD_NOT_SUPPORTED\"] = 400] = \"METHOD_NOT_SUPPORTED\";\n})(CONNECT_ITEM_ERROR_CODES || (CONNECT_ITEM_ERROR_CODES = {}));\nvar SEND_TRANSACTION_ERROR_CODES;\n(function (SEND_TRANSACTION_ERROR_CODES) {\n  SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES[\"UNKNOWN_ERROR\"] = 0] = \"UNKNOWN_ERROR\";\n  SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES[\"BAD_REQUEST_ERROR\"] = 1] = \"BAD_REQUEST_ERROR\";\n  SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES[\"UNKNOWN_APP_ERROR\"] = 100] = \"UNKNOWN_APP_ERROR\";\n  SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES[\"USER_REJECTS_ERROR\"] = 300] = \"USER_REJECTS_ERROR\";\n  SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES[\"METHOD_NOT_SUPPORTED\"] = 400] = \"METHOD_NOT_SUPPORTED\";\n})(SEND_TRANSACTION_ERROR_CODES || (SEND_TRANSACTION_ERROR_CODES = {}));\nvar SIGN_DATA_ERROR_CODES;\n(function (SIGN_DATA_ERROR_CODES) {\n  SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES[\"UNKNOWN_ERROR\"] = 0] = \"UNKNOWN_ERROR\";\n  SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES[\"BAD_REQUEST_ERROR\"] = 1] = \"BAD_REQUEST_ERROR\";\n  SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES[\"UNKNOWN_APP_ERROR\"] = 100] = \"UNKNOWN_APP_ERROR\";\n  SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES[\"USER_REJECTS_ERROR\"] = 300] = \"USER_REJECTS_ERROR\";\n  SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES[\"METHOD_NOT_SUPPORTED\"] = 400] = \"METHOD_NOT_SUPPORTED\";\n})(SIGN_DATA_ERROR_CODES || (SIGN_DATA_ERROR_CODES = {}));\nvar DISCONNECT_ERROR_CODES;\n(function (DISCONNECT_ERROR_CODES) {\n  DISCONNECT_ERROR_CODES[DISCONNECT_ERROR_CODES[\"UNKNOWN_ERROR\"] = 0] = \"UNKNOWN_ERROR\";\n  DISCONNECT_ERROR_CODES[DISCONNECT_ERROR_CODES[\"BAD_REQUEST_ERROR\"] = 1] = \"BAD_REQUEST_ERROR\";\n  DISCONNECT_ERROR_CODES[DISCONNECT_ERROR_CODES[\"UNKNOWN_APP_ERROR\"] = 100] = \"UNKNOWN_APP_ERROR\";\n  DISCONNECT_ERROR_CODES[DISCONNECT_ERROR_CODES[\"METHOD_NOT_SUPPORTED\"] = 400] = \"METHOD_NOT_SUPPORTED\";\n})(DISCONNECT_ERROR_CODES || (DISCONNECT_ERROR_CODES = {}));\nvar CHAIN;\n(function (CHAIN) {\n  CHAIN[\"MAINNET\"] = \"-239\";\n  CHAIN[\"TESTNET\"] = \"-3\";\n})(CHAIN || (CHAIN = {}));\nfunction encodeUint8Array(value, urlSafe) {\n  const encoded = nacl.encodeBase64(value);\n  if (!urlSafe) {\n    return encoded;\n  }\n  return encodeURIComponent(encoded);\n}\nfunction decodeToUint8Array(value, urlSafe) {\n  if (urlSafe) {\n    value = decodeURIComponent(value);\n  }\n  return nacl.decodeBase64(value);\n}\nfunction encode(value, urlSafe = false) {\n  let uint8Array;\n  if (value instanceof Uint8Array) {\n    uint8Array = value;\n  } else {\n    if (typeof value !== 'string') {\n      value = JSON.stringify(value);\n    }\n    uint8Array = nacl.decodeUTF8(value);\n  }\n  return encodeUint8Array(uint8Array, urlSafe);\n}\nfunction decode(value, urlSafe = false) {\n  const decodedUint8Array = decodeToUint8Array(value, urlSafe);\n  return {\n    toString() {\n      return nacl.encodeUTF8(decodedUint8Array);\n    },\n    toObject() {\n      try {\n        return JSON.parse(nacl.encodeUTF8(decodedUint8Array));\n      } catch (e) {\n        return null;\n      }\n    },\n    toUint8Array() {\n      return decodedUint8Array;\n    }\n  };\n}\nconst Base64 = {\n  encode,\n  decode\n};\nfunction concatUint8Arrays(buffer1, buffer2) {\n  const mergedArray = new Uint8Array(buffer1.length + buffer2.length);\n  mergedArray.set(buffer1);\n  mergedArray.set(buffer2, buffer1.length);\n  return mergedArray;\n}\nfunction splitToUint8Arrays(array, index) {\n  if (index >= array.length) {\n    throw new Error('Index is out of buffer');\n  }\n  const subArray1 = array.slice(0, index);\n  const subArray2 = array.slice(index);\n  return [subArray1, subArray2];\n}\nfunction toHexString(byteArray) {\n  let hexString = '';\n  byteArray.forEach(byte => {\n    hexString += ('0' + (byte & 0xff).toString(16)).slice(-2);\n  });\n  return hexString;\n}\nfunction hexToByteArray(hexString) {\n  if (hexString.length % 2 !== 0) {\n    throw new Error(`Cannot convert ${hexString} to bytesArray`);\n  }\n  const result = new Uint8Array(hexString.length / 2);\n  for (let i = 0; i < hexString.length; i += 2) {\n    result[i / 2] = parseInt(hexString.slice(i, i + 2), 16);\n  }\n  return result;\n}\nfunction isNode() {\n  return typeof process !== 'undefined' && process.versions != null && process.versions.node != null;\n}\nclass SessionCrypto {\n  constructor(keyPair) {\n    this.nonceLength = 24;\n    this.keyPair = keyPair ? this.createKeypairFromString(keyPair) : this.createKeypair();\n    this.sessionId = toHexString(this.keyPair.publicKey);\n  }\n  createKeypair() {\n    return nacl$1.box.keyPair();\n  }\n  createKeypairFromString(keyPair) {\n    return {\n      publicKey: hexToByteArray(keyPair.publicKey),\n      secretKey: hexToByteArray(keyPair.secretKey)\n    };\n  }\n  createNonce() {\n    return nacl$1.randomBytes(this.nonceLength);\n  }\n  encrypt(message, receiverPublicKey) {\n    const encodedMessage = new TextEncoder().encode(message);\n    const nonce = this.createNonce();\n    const encrypted = nacl$1.box(encodedMessage, nonce, receiverPublicKey, this.keyPair.secretKey);\n    return concatUint8Arrays(nonce, encrypted);\n  }\n  decrypt(message, senderPublicKey) {\n    const [nonce, internalMessage] = splitToUint8Arrays(message, this.nonceLength);\n    const decrypted = nacl$1.box.open(internalMessage, nonce, senderPublicKey, this.keyPair.secretKey);\n    if (!decrypted) {\n      throw new Error(`Decryption error: \\n message: ${message.toString()} \\n sender pubkey: ${senderPublicKey.toString()} \\n keypair pubkey: ${this.keyPair.publicKey.toString()} \\n keypair secretkey: ${this.keyPair.secretKey.toString()}`);\n    }\n    return new TextDecoder().decode(decrypted);\n  }\n  stringifyKeypair() {\n    return {\n      publicKey: toHexString(this.keyPair.publicKey),\n      secretKey: toHexString(this.keyPair.secretKey)\n    };\n  }\n}\nexport { Base64, CHAIN, CONNECT_EVENT_ERROR_CODES, CONNECT_ITEM_ERROR_CODES, DISCONNECT_ERROR_CODES, SEND_TRANSACTION_ERROR_CODES, SIGN_DATA_ERROR_CODES, SessionCrypto, concatUint8Arrays, hexToByteArray, isNode, splitToUint8Arrays, toHexString };\n//# sourceMappingURL=index.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}